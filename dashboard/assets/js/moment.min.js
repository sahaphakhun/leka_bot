// Simple moment.js replacement for CSP compliance
(function() {
  'use strict';
  
  var moment = function(input, format, locale, strict) {
    if (input === undefined) {
      return new Date();
    }
    if (input instanceof Date) {
      return input;
    }
    if (typeof input === 'string' || typeof input === 'number') {
      return new Date(input);
    }
    return new Date();
  };

  // Static methods
  moment.utc = function(input) {
    if (input === undefined) {
      return new Date();
    }
    return new Date(input);
  };

  moment.unix = function(timestamp) {
    return new Date(timestamp * 1000);
  };

  // Static timezone function
  moment.tz = function(input, timezone) {
    if (timezone === 'Asia/Bangkok') {
      var date = new Date(input);
      var utc = date.getTime() + (date.getTimezoneOffset() * 60000);
      return moment(new Date(utc + (7 * 3600000)));
    }
    return moment(input);
  };

  // Instance methods
  moment.fn = moment.prototype = {
    format: function(format) {
      if (format === 'YYYY-MM-DD') {
        return this.toISOString().split('T')[0];
      }
      if (format === 'HH:mm') {
        return this.toTimeString().slice(0, 5);
      }
      if (format === 'DD/MM/YYYY') {
        return this.toLocaleDateString('th-TH');
      }
      return this.toLocaleString('th-TH');
    },
    
    tz: function(timezone) {
      if (timezone === 'Asia/Bangkok') {
        var utc = this.getTime() + (this.getTimezoneOffset() * 60000);
        var bangkokTime = new Date(utc + (7 * 3600000));
        return moment(bangkokTime);
      }
      return this;
    },
    
    add: function(amount, unit) {
      var date = new Date(this);
      if (unit === 'days') {
        date.setDate(date.getDate() + amount);
      } else if (unit === 'hours') {
        date.setHours(date.getHours() + amount);
      } else if (unit === 'minutes') {
        date.setMinutes(date.getMinutes() + amount);
      }
      return moment(date);
    },
    
    subtract: function(amount, unit) {
      return this.add(-amount, unit);
    },
    
    isBefore: function(other) {
      return this < other;
    },
    
    isAfter: function(other) {
      return this > other;
    },
    
    isSame: function(other) {
      return this.getTime() === other.getTime();
    },
    
    diff: function(other, unit) {
      var diff = this.getTime() - other.getTime();
      if (unit === 'days') {
        return Math.floor(diff / (1000 * 60 * 60 * 24));
      }
      if (unit === 'hours') {
        return Math.floor(diff / (1000 * 60 * 60));
      }
      if (unit === 'minutes') {
        return Math.floor(diff / (1000 * 60));
      }
      return diff;
    }
  };

  // Extend moment with timezone support
  moment.tz.setDefault = function(timezone) {
    moment._defaultTimezone = timezone;
  };

  // Make moment available globally
  if (typeof window !== 'undefined') {
    window.moment = moment;
  }
  if (typeof global !== 'undefined') {
    global.moment = moment;
  }
  
  return moment;
})();
