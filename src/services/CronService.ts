// Cron Service - ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏±‡∏ô‡∏ï‡∏≤‡∏°‡πÄ‡∏ß‡∏•‡∏≤

import cron from 'node-cron';
import moment from 'moment-timezone';
import { config } from '@/utils/config';
import { TaskService } from './TaskService';
import { NotificationService } from './NotificationService';
import { KPIService } from './KPIService';

export class CronService {
  private taskService: TaskService;
  private notificationService: NotificationService;
  private kpiService: KPIService;
  private jobs: Map<string, cron.ScheduledTask> = new Map();

  constructor() {
    this.taskService = new TaskService();
    this.notificationService = new NotificationService();
    this.kpiService = new KPIService();
  }

  public start(): void {
    console.log('üïê Starting cron jobs...');

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ó‡∏∏‡∏Å 15 ‡∏ô‡∏≤‡∏ó‡∏µ
    const reminderJob = cron.schedule('*/15 * * * *', async () => {
      await this.processReminders();
    }, {
      scheduled: false,
      timezone: config.app.defaultTimezone
    });

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ó‡∏∏‡∏Å‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
    const overdueJob = cron.schedule('0 * * * *', async () => {
      await this.processOverdueTasks();
    }, {
      scheduled: false,
      timezone: config.app.defaultTimezone
    });

    // ‡∏™‡∏£‡∏∏‡∏õ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏£‡∏≤‡∏¢‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå (‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå 09:00)
    const weeklyReportJob = cron.schedule('0 9 * * 1', async () => {
      await this.sendWeeklyReports();
    }, {
      scheduled: false,
      timezone: config.app.defaultTimezone
    });

    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï KPI ‡πÅ‡∏•‡∏∞ Leaderboard ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏á‡∏Ñ‡∏∑‡∏ô
    const kpiUpdateJob = cron.schedule('0 0 * * *', async () => {
      await this.updateKPIRecords();
    }, {
      scheduled: false,
      timezone: config.app.defaultTimezone
    });

    // ‡πÄ‡∏Å‡πá‡∏ö jobs ‡πÑ‡∏ß‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö shutdown
    this.jobs.set('reminder', reminderJob);
    this.jobs.set('overdue', overdueJob);
    this.jobs.set('weeklyReport', weeklyReportJob);
    this.jobs.set('kpiUpdate', kpiUpdateJob);

    // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏á‡∏≤‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    this.jobs.forEach((job, name) => {
      job.start();
      console.log(`‚úÖ Started cron job: ${name}`);
    });
  }

  public stop(): void {
    console.log('üõë Stopping cron jobs...');
    
    this.jobs.forEach((job, name) => {
      job.stop();
      console.log(`‚úÖ Stopped cron job: ${name}`);
    });
    
    this.jobs.clear();
  }

  /**
   * ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏á‡∏≤‡∏ô
   */
  private async processReminders(): Promise<void> {
    try {
      console.log('üîî Processing task reminders...');
      
      const now = moment().tz(config.app.defaultTimezone);
      const upcomingTasks = await this.taskService.getTasksForReminder();

      for (const task of upcomingTasks) {
        const dueTime = moment(task.dueTime).tz(config.app.defaultTimezone);
        const timeDiff = dueTime.diff(now);

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ñ‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        const reminderIntervals = task.customReminders?.length > 0 
          ? task.customReminders 
          : config.app.defaultReminders;

        for (const interval of reminderIntervals) {
          const reminderTime = this.parseReminderInterval(interval);
          const shouldSendAt = dueTime.clone().subtract(reminderTime.amount, reminderTime.unit);
          
          // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏ß‡∏•‡∏≤‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á ‡πÅ‡∏•‡∏∞‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏™‡πà‡∏á
          if (now.isAfter(shouldSendAt) && now.isBefore(shouldSendAt.clone().add(15, 'minutes'))) {
            const alreadySent = task.remindersSent.some(
              reminder => reminder.type === interval && 
              moment(reminder.sentAt).isSame(now, 'hour')
            );

            if (!alreadySent) {
              await this.sendTaskReminder(task, interval);
            }
          }
        }

        // ‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ñ‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡∏≥‡∏´‡∏ô‡∏î
        if (now.isBetween(dueTime.clone().subtract(5, 'minutes'), dueTime.clone().add(5, 'minutes'))) {
          const alreadySent = task.remindersSent.some(
            reminder => reminder.type === 'due' && 
            moment(reminder.sentAt).isSame(now, 'hour')
          );

          if (!alreadySent) {
            await this.sendTaskReminder(task, 'due');
          }
        }
      }

    } catch (error) {
      console.error('‚ùå Error processing reminders:', error);
    }
  }

  /**
   * ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡∏Å‡∏≥‡∏´‡∏ô‡∏î
   */
  private async processOverdueTasks(): Promise<void> {
    try {
      console.log('‚è∞ Processing overdue tasks...');
      
      const overdueTasks = await this.taskService.getOverdueTasks();
      
      for (const task of overdueTasks) {
        // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏õ‡πá‡∏ô overdue
        await this.taskService.updateTaskStatus(task.id, 'overdue');
        
        // ‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
        await this.notificationService.sendOverdueNotification(task);
        
        // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å KPI (‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏•‡∏ö)
        await this.kpiService.recordTaskCompletion(task, 'late');
      }

    } catch (error) {
      console.error('‚ùå Error processing overdue tasks:', error);
    }
  }

  /**
   * ‡∏™‡πà‡∏á‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏£‡∏≤‡∏¢‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå
   */
  private async sendWeeklyReports(): Promise<void> {
    try {
      console.log('üìä Sending weekly reports...');
      
      const groups = await this.taskService.getAllActiveGroups();
      
      for (const group of groups) {
        if (group.settings.enableLeaderboard) {
          const weeklyStats = await this.kpiService.getWeeklyStats(group.id);
          const leaderboard = await this.kpiService.getGroupLeaderboard(group.id, 'weekly');
          
          await this.notificationService.sendWeeklyReport(group, weeklyStats, leaderboard);
        }
      }

    } catch (error) {
      console.error('‚ùå Error sending weekly reports:', error);
    }
  }

  /**
   * ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï KPI Records
   */
  private async updateKPIRecords(): Promise<void> {
    try {
      console.log('üìà Updating KPI records...');
      
      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï leaderboard rankings
      await this.kpiService.updateLeaderboardRankings();
      
      // ‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤ (‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ 1 ‡∏õ‡∏µ)
      await this.kpiService.cleanupOldRecords();

    } catch (error) {
      console.error('‚ùå Error updating KPI records:', error);
    }
  }

  /**
   * ‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏á‡∏≤‡∏ô
   */
  private async sendTaskReminder(task: any, reminderType: string): Promise<void> {
    try {
      await this.notificationService.sendTaskReminder(task, reminderType);
      
      // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ß‡πà‡∏≤‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÅ‡∏•‡πâ‡∏ß
      await this.taskService.recordReminderSent(task.id, reminderType);
      
    } catch (error) {
      console.error('‚ùå Error sending task reminder:', error);
    }
  }

  /**
   * ‡πÅ‡∏õ‡∏•‡∏á reminder interval ‡πÄ‡∏õ‡πá‡∏ô moment duration
   */
  private parseReminderInterval(interval: string): { amount: number; unit: moment.unitOfTime.DurationConstructor } {
    // ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö: '7d', '1h', '30m', 'P7D', 'PT3H'
    
    if (interval.startsWith('P')) {
      // ISO 8601 Duration format
      const match = interval.match(/P(?:(\d+)D)?T?(?:(\d+)H)?(?:(\d+)M)?/);
      if (match) {
        const [, days, hours, minutes] = match;
        if (days) return { amount: parseInt(days), unit: 'days' };
        if (hours) return { amount: parseInt(hours), unit: 'hours' };
        if (minutes) return { amount: parseInt(minutes), unit: 'minutes' };
      }
    } else {
      // Simple format: 7d, 1h, 30m
      const match = interval.match(/^(\d+)([dhm])$/);
      if (match) {
        const [, amount, unit] = match;
        const unitMap = { d: 'days', h: 'hours', m: 'minutes' } as const;
        return { 
          amount: parseInt(amount), 
          unit: unitMap[unit as keyof typeof unitMap] 
        };
      }
    }

    // Default fallback
    return { amount: 1, unit: 'hours' };
  }
}