// Webhook Controller - ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Webhook ‡∏à‡∏≤‡∏Å LINE

import { Router, Request, Response } from 'express';
import { WebhookEvent, MessageEvent, PostbackEvent, ImageMessage, VideoMessage, AudioMessage } from '@line/bot-sdk';
import { LineService } from '@/services/LineService';
import { TaskService } from '@/services/TaskService';
import { UserService } from '@/services/UserService';
import { FileService } from '@/services/FileService';
import { FlexMessageDesignSystem } from '@/services/FlexMessageDesignSystem';
import { FlexMessageTemplateService } from '@/services/FlexMessageTemplateService';
import { CommandService } from '@/services/CommandService';
import { config } from '@/utils/config';
import { serviceContainer } from '@/utils/serviceContainer';
import { logger } from '@/utils/logger';
import { formatFileSize } from '@/utils/common';

export const webhookRouter = Router();

class WebhookController {
  private lineService: LineService;
  private taskService: TaskService;
  private userService: UserService;
  private fileService: FileService;
  private commandService: CommandService;

  constructor() {
    this.lineService = serviceContainer.get<LineService>('LineService');
    this.taskService = serviceContainer.get<TaskService>('TaskService');
    this.userService = serviceContainer.get<UserService>('UserService');
    this.fileService = serviceContainer.get<FileService>('FileService');
    this.commandService = serviceContainer.get<CommandService>('CommandService');
  }

  /**
   * ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Webhook Event ‡∏à‡∏≤‡∏Å LINE
   */
  public async handleWebhook(req: Request, res: Response): Promise<void> {
    try {
      const signature = req.get('X-Line-Signature');
      if (!signature) {
        res.status(400).json({ error: 'Missing signature' });
        return;
      }

      // parse raw body (express.raw) ‚Üí text ‚Üí validate signature ‚Üí JSON.parse
      const rawBodyBuffer = (req as any).body as Buffer;
      const body = rawBodyBuffer ? rawBodyBuffer.toString('utf8') : JSON.stringify(req.body || {});
      
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö signature
      if (!this.lineService.validateSignature(body, signature)) {
        res.status(401).json({ error: 'Invalid signature' });
        return;
      }
      const parsed = body ? JSON.parse(body) : {};
      const events: WebhookEvent[] = parsed.events || [];
      
      // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• events ‡πÅ‡∏ö‡∏ö parallel
      await Promise.all(events.map(event => this.processEvent(event)));
      
      res.status(200).json({ message: 'OK' });

    } catch (error) {
      logger.error('Webhook error:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  /**
   * ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• Event ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó
   */
  private async processEvent(event: WebhookEvent): Promise<void> {
    try {
      logger.info('Processing event:', { type: event.type, source: event.source });

      switch (event.type) {
        case 'message':
          await this.handleMessageEvent(event as MessageEvent);
          break;
          
        case 'postback':
          await this.handlePostbackEvent(event as PostbackEvent);
          break;
          
        case 'join':
          await this.handleJoinEvent(event);
          break;
          
        case 'leave':
          await this.handleLeaveEvent(event);
          break;
          
        case 'memberJoined':
          await this.handleMemberJoinedEvent(event);
          break;
          
        case 'memberLeft':
          await this.handleMemberLeftEvent(event);
          break;

        default:
          logger.info('Unhandled event type:', { type: event.type });
      }

    } catch (error) {
      logger.error('Error processing event:', error);
    }
  }

  /**
   * ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
   */
  private async handleMessageEvent(event: MessageEvent): Promise<void> {
    const { message, source, replyToken } = event;

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (source.type !== 'group') {
      await this.lineService.replyMessage(replyToken!, 
        '‡∏ö‡∏≠‡∏ó‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏° LINE ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô‡∏Ñ‡πà‡∏∞');
      return;
    }

    const groupId = source.groupId!;
    const userId = source.userId!;

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á user/group record ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ
    await this.ensureUserAndGroup(userId, groupId);

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
    await this.checkAndSaveNewMemberFromMessage(groupId, userId);

    switch (message.type) {
      case 'text':
        await this.handleTextMessage(event, message.text);
        break;
        
      case 'image':
      case 'video':
      case 'audio':
      // Note: File messages are handled through other message types
      // case 'file':
      //   await this.handleFileMessage(event, message as any);
      //   break;

          // ‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß - ‡∏£‡∏≠‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á "‡πÄ‡∏ã‡∏ü‡πÑ‡∏ü‡∏•‡πå"
          console.log('üìÅ ‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡πÅ‡∏•‡πâ‡∏ß (‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥)');
          break;
        
      default:
        console.log('‚ÑπÔ∏è Unhandled message type:', message.type);
    }
  }

  /**
   * ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ö‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
   */
  private async handleTextMessage(event: MessageEvent, text: string): Promise<void> {
    const { source, replyToken } = event;
    
    console.log('üìù Processing text message:', text);
    
    // ‡πÅ‡∏¢‡∏Å‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á
    const command = this.lineService.parseCommand(text, event);
    
    if (command) {
      // ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ö‡∏≠‡∏ó
      console.log('‚úÖ Command detected, executing:', command.command);
      try {
        const response = await this.commandService.executeCommand(command);
        
        if (response) {
          // ‡πÄ‡∏û‡∏¥‡πà‡∏° logging ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö response
          console.log('üì§ Command response type:', typeof response);
          if (typeof response !== 'string') {
            console.log('üé¥ Response is Flex Message:', {
              type: response.type,
              altText: response.altText
            });
          } else {
            console.log('üìù Response is Text Message:', response.substring(0, 100) + '...');
          }
          
          await this.lineService.replyMessage(replyToken!, response);
          console.log('üì§ Bot response sent');
        } else {
          console.log('‚ö†Ô∏è No response from command service');
        }
      } catch (error) {
        console.error('‚ùå Error executing command:', error);
        await this.lineService.replyMessage(replyToken!, 
          '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
      }
    } else {
      // ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ö‡∏≠‡∏ó - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡∏ß‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      console.log('‚ùå Not a bot command');
      
      // ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏û‡∏π‡∏î‡∏ñ‡∏∂‡∏á‡∏ö‡∏≠‡∏ó‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÅ‡∏ó‡πá‡∏Å)
      if (text.toLowerCase().includes('‡πÄ‡∏•‡∏Ç‡∏≤') && 
          !text.includes('@‡πÄ‡∏•‡∏Ç‡∏≤') && 
          (text.includes('‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ') || text.includes('hello') || text.includes('hi'))) {
        // ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ó‡∏±‡∏Å‡∏ó‡∏≤‡∏¢
        const helpText = `‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡πà‡∏∞ ‡∏â‡∏±‡∏ô‡∏Ñ‡∏∑‡∏≠‡πÄ‡∏•‡∏Ç‡∏≤‡∏ö‡∏≠‡∏ó‡∏Ñ‡πà‡∏∞ ü§ñ

üìù ‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:
‚Ä¢ ‡πÅ‡∏ó‡πá‡∏Å‡∏ö‡∏≠‡∏ó‡πÉ‡∏ô LINE ‡πÅ‡∏•‡πâ‡∏ß‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á
‚Ä¢ ‡∏´‡∏£‡∏∑‡∏≠‡∏û‡∏¥‡∏°‡∏û‡πå @‡πÄ‡∏•‡∏Ç‡∏≤ <‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á>
‚Ä¢ ‡∏´‡∏£‡∏∑‡∏≠‡∏û‡∏¥‡∏°‡∏û‡πå /<‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á>

üîß ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô: ‡πÅ‡∏ó‡πá‡∏Å‡∏ö‡∏≠‡∏ó /help ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î`;

        await this.lineService.replyMessage(replyToken!, helpText);
      }
      // ‡πÑ‡∏°‡πà‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏£‡∏ö‡∏Å‡∏ß‡∏ô
    }
  }

  /**
   * ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î
   */
  private async handleFileMessage(event: MessageEvent, message: ImageMessage | VideoMessage | AudioMessage): Promise<void> {
    try {
      const { source, replyToken } = event;
      const groupId = source.type === 'group' ? (source as any).groupId : '';
      const userId = source.userId!;

      // ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå
      const content = await this.lineService.downloadContent((message as any).id);
      
      // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ü‡∏•‡πå
      const fileRecord = await this.fileService.saveFile({
        groupId,
        uploadedBy: userId,
        messageId: (message as any).id,
        content,
        originalName: (message as any).fileName || `file_${(message as any).id}`,
        mimeType: message.type === 'image' ? 'image/jpeg' : 
                  message.type === 'video' ? 'video/mp4' :
                  message.type === 'audio' ? 'audio/mpeg' : 
                  'application/octet-stream',
        folderStatus: 'in_progress'
      });

      // ‡∏™‡∏£‡πâ‡∏≤‡∏á Flex Message ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
      const fileContent = [
        FlexMessageDesignSystem.createText(`‡πÑ‡∏ü‡∏•‡πå: ${fileRecord.originalName}`, 'sm', FlexMessageDesignSystem.colors.textPrimary),
        FlexMessageDesignSystem.createText(`‡∏Ç‡∏ô‡∏≤‡∏î: ${this.formatFileSize(fileRecord.size)}`, 'sm', FlexMessageDesignSystem.colors.textPrimary)
      ];

      const fileButtons = [
        FlexMessageDesignSystem.createButton(
          '‡∏ú‡∏π‡∏Å‡∏Å‡∏±‡∏ö‡∏á‡∏≤‡∏ô',
          'postback',
          `action=link_file&fileId=${fileRecord.id}`,
          'primary'
        ),
        FlexMessageDesignSystem.createButton(
          '‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏ó‡πá‡∏Å',
          'postback',
          `action=tag_file&fileId=${fileRecord.id}`,
          'secondary'
        )
      ];

      const flexMessage = FlexMessageDesignSystem.createStandardTaskCard(
        '‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏•‡πâ‡∏ß',
        'üìÅ',
        FlexMessageDesignSystem.colors.success,
        fileContent,
        fileButtons,
        'compact'
      );

      await this.lineService.replyMessage(replyToken!, flexMessage as any);

    } catch (error) {
      console.error('‚ùå Error handling file message:', error);
      await this.lineService.replyMessage(event.replyToken!, 
        '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ü‡∏•‡πå');
    }
  }

  /**
   * ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Postback Event (‡∏à‡∏≤‡∏Å‡∏õ‡∏∏‡πà‡∏°‡∏ï‡πà‡∏≤‡∏á‡πÜ)
   */
  private async handlePostbackEvent(event: PostbackEvent): Promise<void> {
    const { replyToken, source } = event;
    const data = (event as any).postback?.data;
    const groupId = source.type === 'group' ? source.groupId! : '';
    const userId = source.userId!;

    try {
      const params = new URLSearchParams(data);
      const action = params.get('action');

      switch (action) {
        case 'complete':
        case 'complete_task':
          const taskId = params.get('taskId');
          if (taskId) {
            try {
              await this.taskService.completeTask(taskId, userId);
              await this.lineService.replyMessage(replyToken, '‚úÖ ‡∏õ‡∏¥‡∏î‡∏á‡∏≤‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß');
            } catch (err: any) {
              await this.lineService.replyMessage(replyToken, `‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏¥‡∏î‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ: ${err.message || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î'}`);
            }
          }
          break;

        case 'submit_confirm': {
          const taskId = params.get('taskId')!;
          const fileIdsParam = params.get('fileIds') || '';
          const note = params.get('note') || '';
          const fileIds = fileIdsParam ? fileIdsParam.split(',').filter(Boolean) : [];
          try {
            const task = await this.taskService.recordSubmission(taskId, userId, fileIds, note);
            await this.lineService.replyMessage(replyToken, `üì• ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏á‡∏≤‡∏ô‡πÉ‡∏´‡πâ "${task.title}" ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏∞`);
          } catch (err: any) {
            await this.lineService.replyMessage(replyToken, `‚ùå ‡∏™‡πà‡∏á‡∏á‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ${err.message || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î'}`);
          }
          break;
        }

        case 'submit_nofile': {
          const taskId = params.get('taskId')!;
          const note = params.get('note') || '';
          try {
            const task = await this.taskService.recordSubmission(taskId, userId, [], note);
            await this.lineService.replyMessage(replyToken, `üì• ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏á‡∏≤‡∏ô (‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ô‡∏ö) ‡πÉ‡∏´‡πâ "${task.title}" ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏∞`);
          } catch (err: any) {
            await this.lineService.replyMessage(replyToken, `‚ùå ‡∏™‡πà‡∏á‡∏á‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ${err.message || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î'}`);
          }
          break;
        }

        case 'submit_cancel':
          await this.lineService.replyMessage(replyToken, '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß');
          break;

        case 'submit_with_files': {
          const taskId = params.get('taskId')!;
          try {
            // ‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡∏ö‡πÑ‡∏ü‡∏•‡πå
            const task = await this.taskService.getTaskById(taskId);
            const group = { id: groupId, lineGroupId: groupId, name: '‡∏Å‡∏•‡∏∏‡πà‡∏°' };
            const assignee = await this.userService.findByLineUserId(userId);
            
            const fileAttachmentCard = FlexMessageTemplateService.createFileAttachmentCard(task, group, assignee);
            await this.lineService.replyMessage(replyToken, fileAttachmentCard);
          } catch (err: any) {
            await this.lineService.replyMessage(replyToken, `‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÅ‡∏ô‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ: ${err.message || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î'}`);
          }
          break;
        }

        case 'confirm_submit': {
          const taskId = params.get('taskId')!;
          try {
            // ‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏á‡∏≤‡∏ô
            const task = await this.taskService.getTaskById(taskId);
            const group = { id: groupId, lineGroupId: groupId, name: '‡∏Å‡∏•‡∏∏‡πà‡∏°' };
            
            // ‡∏´‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏™‡πà‡∏á‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î (24 ‡∏ä‡∏°.)
            const since = new Date(Date.now() - 24 * 60 * 60 * 1000);
            const { files } = await this.fileService.getGroupFiles(groupId, { startDate: since });
            
            const submitConfirmationCard = FlexMessageTemplateService.createSubmitConfirmationCard(
              task, 
              group, 
              files.length, 
              files.map((f: any) => f.originalName)
            );
            await this.lineService.replyMessage(replyToken, submitConfirmationCard);
          } catch (err: any) {
            await this.lineService.replyMessage(replyToken, `‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÑ‡∏î‡πâ: ${err.message || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î'}`);
          }
          break;
        }

        case 'approve_task': {
          const taskId2 = params.get('taskId');
          if (taskId2) {
            try {
              await this.taskService.completeTask(taskId2, userId);
              await this.lineService.replyMessage(replyToken, '‚úÖ ‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡∏∞‡∏õ‡∏¥‡∏î‡∏á‡∏≤‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢');
            } catch (err: any) {
              await this.lineService.replyMessage(replyToken, `‚ùå ‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ${err.message || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î'}`);
            }
          }
          break;
        }

        case 'edit':
          // TODO: ‡∏™‡πà‡∏á‡∏•‡∏¥‡∏á‡∏Å‡πå‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
          break;

        case 'link_file':
          const fileId = params.get('fileId');
          if (fileId) {
            const tasks = await this.taskService.getActiveTasks(groupId);
            // TODO: ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏á‡∏≤‡∏ô‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
          }
          break;

        case 'link_files': {
          const fileIdsParam = params.get('fileIds');
          if (fileIdsParam) {
            const fileIds = fileIdsParam.split(',').filter(Boolean);
            const tasks = await this.taskService.getActiveTasks(groupId);
            
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á Flex Message ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏á‡∏≤‡∏ô‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
            const taskButtons = tasks.slice(0, 5).map((task: any) => 
              FlexMessageDesignSystem.createButton(
                `${task.title} (${task.id.substring(0, 8)})`,
                'postback',
                `action=link_files_to_task&taskId=${task.id}&fileIds=${fileIds.join(',')}`,
                'secondary'
              )
            );

            const footerButtons = [
              FlexMessageDesignSystem.createButton(
                '‡πÑ‡∏°‡πà‡∏ú‡∏π‡∏Å‡∏Å‡∏±‡∏ö‡∏á‡∏≤‡∏ô',
                'postback',
                `action=no_link_files&fileIds=${fileIds.join(',')}`,
                'primary'
              )
            ];

            const flexMessage = FlexMessageDesignSystem.createStandardTaskCard(
              'üìã ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏á‡∏≤‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ú‡∏π‡∏Å‡πÑ‡∏ü‡∏•‡πå',
              'üìã',
              FlexMessageDesignSystem.colors.primary,
              [
                FlexMessageDesignSystem.createText(`‡πÑ‡∏ü‡∏•‡πå ${fileIds.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`, 'sm', FlexMessageDesignSystem.colors.textSecondary),
                ...taskButtons
              ],
              footerButtons,
              'compact'
            );
            
            await this.lineService.replyMessage(replyToken, flexMessage as any);
          }
          break;
        }

        case 'link_files_to_task': {
          const taskId = params.get('taskId');
          const fileIdsParam = params.get('fileIds');
          if (taskId && fileIdsParam) {
            const fileIds = fileIdsParam.split(',').filter(Boolean);
            try {
              // ‡∏ú‡∏π‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏Å‡∏±‡∏ö‡∏á‡∏≤‡∏ô
              for (const fileId of fileIds) {
                await this.fileService.linkFileToTask(fileId, taskId);
              }
              await this.lineService.replyMessage(replyToken, '‚úÖ ‡∏ú‡∏π‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏Å‡∏±‡∏ö‡∏á‡∏≤‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß');
            } catch (err: any) {
              await this.lineService.replyMessage(replyToken, `‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ú‡∏π‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ: ${err.message || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î'}`);
            }
          }
          break;
        }

        case 'no_link_files': {
          const fileIdsParam = params.get('fileIds');
          if (fileIdsParam) {
            await this.lineService.replyMessage(replyToken, '‚úÖ ‡πÑ‡∏ü‡∏•‡πå‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡πâ‡∏ß‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ú‡∏π‡∏Å‡∏Å‡∏±‡∏ö‡∏á‡∏≤‡∏ô');
          }
          break;
        }

        case 'view_saved_files': {
          const fileIdsParam = params.get('fileIds');
          if (fileIdsParam) {
            const fileIds = fileIdsParam.split(',').filter(Boolean);
            // ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡πâ‡∏ß
            let response = 'üìÅ ‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡πâ‡∏ß:\n\n';
            for (const fileId of fileIds) {
              try {
                const file = await this.fileService.getFilesByIds([fileId]);
                if (file && file.length > 0) {
                  const fileData = file[0];
                  response += `üìÑ ${fileData.originalName}\n`;
                  response += `üì¶ ${this.formatFileSize(fileData.size)}\n`;
                  response += `üë§ ${fileData.uploadedByUser?.displayName || '‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö'}\n\n`;
                }
              } catch (error) {
                console.error('Error getting file:', error);
              }
            }
            await this.lineService.replyMessage(replyToken, response);
          }
          break;
        }

        default:
          console.log('‚ÑπÔ∏è Unhandled postback action:', action);
      }

    } catch (error) {
      console.error('‚ùå Error handling postback:', error);
      await this.lineService.replyMessage(replyToken, '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà');
    }
  }

  /**
   * ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ö‡∏≠‡∏ó‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏•‡∏∏‡πà‡∏°
   */
  private async handleJoinEvent(event: WebhookEvent): Promise<void> {
    if (event.source.type === 'group') {
      const groupId = event.source.groupId!;
      
      const welcomeMessage = `‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡πà‡∏∞! ‡∏â‡∏±‡∏ô‡∏Ñ‡∏∑‡∏≠‡πÄ‡∏•‡∏Ç‡∏≤‡∏ö‡∏≠‡∏ó ü§ñ
      
‡∏â‡∏±‡∏ô‡∏à‡∏∞‡∏ä‡πà‡∏ß‡∏¢‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡∏∞‡∏õ‡∏è‡∏¥‡∏ó‡∏¥‡∏ô‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ô‡∏µ‡πâ‡∏Ñ‡πà‡∏∞

‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:
1. ‡∏û‡∏¥‡∏°‡∏û‡πå "@‡πÄ‡∏•‡∏Ç‡∏≤ /setup" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ö‡∏•‡∏¥‡∏á‡∏Å‡πå Dashboard ‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏°
2. ‡∏ú‡∏π‡πâ‡∏î‡∏π‡πÅ‡∏•‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏î‡∏±‡∏á‡∏Å‡∏•‡πà‡∏≤‡∏ß
3. ‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô‡∏û‡∏¥‡∏°‡∏û‡πå "@‡πÄ‡∏•‡∏Ç‡∏≤ /whoami" ‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡∏î‡∏•‡∏¥‡∏á‡∏Å‡πå "‡πÄ‡∏õ‡∏¥‡∏î‡∏´‡∏ô‡πâ‡∏≤‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå (‡πÄ‡∏ß‡πá‡∏ö)" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏à‡∏£‡∏¥‡∏á/‡∏≠‡∏µ‡πÄ‡∏°‡∏•/‡πÄ‡∏Ç‡∏ï‡πÄ‡∏ß‡∏•‡∏≤

‡∏û‡∏¥‡∏°‡∏û‡πå "@‡πÄ‡∏•‡∏Ç‡∏≤ /help" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ñ‡πà‡∏∞ ‚ú®`;

      await this.lineService.pushMessage(groupId, welcomeMessage);
    }
  }

  /**
   * ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ö‡∏≠‡∏ó‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡∏∏‡πà‡∏°
   */
  private async handleLeaveEvent(event: WebhookEvent): Promise<void> {
    if (event.source.type === 'group') {
      const groupId = event.source.groupId!;
      
      // TODO: ‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÄ‡∏õ‡πá‡∏ô inactive
      await this.userService.deactivateGroup(groupId);
    }
  }

  /**
   * ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°
   */
  private async handleMemberJoinedEvent(event: WebhookEvent): Promise<void> {
    // TODO: ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡πÅ‡∏•‡∏∞‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö
  }

  /**
   * ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡∏∏‡πà‡∏°
   */
  private async handleMemberLeftEvent(event: WebhookEvent): Promise<void> {
    // TODO: ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å
  }

  /**
   * ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á User/Group record
   */
  private async ensureUserAndGroup(userId: string, groupId: string): Promise<void> {
    try {
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö user
      let user = await this.userService.findByLineUserId(userId);
      if (!user) {
        const profile = await this.lineService.getUserProfile(userId);
        user = await this.userService.createUser({
          lineUserId: userId,
          displayName: profile.displayName
        });
      }

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö group
      let group = await this.userService.findGroupByLineId(groupId);
      if (!group) {
        group = await this.userService.createGroup({
          lineGroupId: groupId,
          name: `‡∏Å‡∏•‡∏∏‡πà‡∏° ${groupId.substring(0, 8)}`
        });
      }

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö membership
      const membership = await this.userService.findGroupMembership(user.id, group.id);
      if (!membership) {
        await this.userService.addGroupMember(group.id, user.id);
      }

    } catch (error) {
      console.error('‚ùå Error ensuring user and group:', error);
    }
  }

  /**
   * ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
   */
  private async checkAndSaveNewMemberFromMessage(groupId: string, userId: string): Promise<void> {
    try {
      console.log(`üîç ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°: ${userId} ‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏° ${groupId}`);
      
      // ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏ô LineService
      const result = await this.lineService.checkAndSaveNewMemberFromMessage(groupId, userId);
      
      if (result.isNewMember && result.memberInfo) {
        console.log(`üÜï ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°: ${result.memberInfo.displayName}`);
        
        // ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡πÉ‡∏´‡∏°‡πà (‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£)
        // await this.lineService.pushMessage(groupId, 
        //   `‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö ${result.memberInfo.displayName} ‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏Ñ‡πà‡∏∞! üëã`);
      }
      
    } catch (error) {
      console.error('‚ùå Error checking and saving new member from message:', error);
    }
  }

  /**
   * ‡∏à‡∏±‡∏î‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏ü‡∏•‡πå
   */
  private formatFileSize(bytes: number): string {
    return formatFileSize(bytes);
  }
}

const webhookController = new WebhookController();

// Routes
webhookRouter.post('/', (req, res) => webhookController.handleWebhook(req, res));